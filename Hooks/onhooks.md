---
title: On Hooks
nav-order: 2
parent: Hooks
---

# On Hooks
On Hooks are a type of hooks that are generated by MonoMod HookGen. This allows you to hook onto and replace any method in the games code.
Any function (private or public) that the game's code has can be onHooked which makes the combination of Modhooks and OnHooks very useful while creating a mod.
OnHooks allow you to do 2 main things
1. Insert code before/after a method is run.
2. Replace the games method with your code.  

To subscribe to OnHook you'd first need to find a method. In this example we will be using `HeroController.AddGeo(int amount)` to demonstrate. 
So to OnHook `HeroController.AddGeo` we would do:
```cs
//We subscribe to the hook
On.HeroController.AddGeo += OnHCAddGeo;

   
private void OnHCAddGeo(On.HeroController.orig_AddGeo orig, HeroController self, int amount)
{
    //code before original method is called
    if (amount < 100)
    {
        //if amount of geo to be added is less than 100, return (and dont call original method)
        return;
    }
    
    orig(self, amount); // call original method
    
    //code after method is called
    Log($"the amount of total geo is {self.geoCounter.playerData.geo}"
}
```

From the above example, the function generated contains an odd looking argument `On.HeroController.orig_AddGeo` called `orig`. This is a delegate that will allow us to call the original function if we wish.  
The second argument `HeroController self` is the object that the method is being called on. Since this method is not static, it is called on an instance of the class (in this case HeroController) which is then passed as an argument for us to use.
Note that this argument will not be present for static methods.  
The third argument `int amount` is the normal argument the function takes.

To call the original method we would do: `orig(self, amount)`. We call orig and pass in self and the rest of the arguments of the function (in this case `int amount`).
In the case the function has no other arguments we would just do `orig(self)`. If the function had more arguments, we would pass those in too after self.

While using OnHooks we need to be careful of a few things
1. If your goal is to insert code before/after a method has run, don't forget to call `orig(self)` or it might cause some unexpected behaviour especially for important functions like HeroController.Start and PlayerMakerFSM.Awake.
2. Unless necessary for the mod, dont replace the method with your own because if `orig(self)` is not called, other mods that also OnHooked this method will not be able to run their code. 
This is because the second mod's onHook will only be called when the first mod's onHook calls `orig(self)` (i.e. if first mod never calls `orig(self)` second mod's hook wont be called). 
If the vanilla game code is conflicting with your mod then by all means do replace the method but just make sure to keep this in mind.
3. If you want to replace a method, make sure to not call `orig(self)`. Also if you do this it is very likely you will encounter private fields and methods that you would like to access. 
To be able to do this, [Reflection](reflection.md) is the best way to do it.

> Note: Your IDE (Visual Studio Community/Jetbrains Rider) can generate this function for you with the correct parameters.  To do this, [see example video](https://youtu.be/oH-lbfZORw0) or type in `On.HeroController.AddGeo += OnHCAddGeo;`, Then right click on the now red highlighted `OnHCAwake` and click on the light bulb icon (called 'Quick actions and Refactoring') and choose 'Generate Method'.

> Note: To be able to write OnHooks, you will need to import `MMHOOK_Assembly-CSharp.dll` and `MMHOOK_PlayMaker.dll` from your managed folder.

## Order of Execution
If multiple mods On Hook the same method, it might be important to understand the order of importance. Lets say 3 mods exist, Mod A, B and C and they subscribe in that order, then the for the execution of the hooks are:

- C does stuff before orig(self)
- B does stuff before orig(self)
- A does stuff before orig(self)
- The original function runs
- A does stuff after orig(self)
- B does stuff after orig(self)
- C does stuff after orig(self)

This order becomes especially imporant when one of the mods doesn't call orig(self). For example if B chooses not to call orig(self), then everything between "B does stuff before orig(self)" and "B does stuff after orig(self)" gets skipped (so C is fine but A is ignored).


###  TODO
- Show common hooks
- Explanation of order of execution of multiple mod using on hooks (this is here because im not knowledgeable about it)
- Show how to hook using reflection (for mapi created orig_Methods) 
  - because it allows you to edit methods that are assembly edited by mapi